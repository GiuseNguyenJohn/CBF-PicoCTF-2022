# flag leak

Author: David

## Description

Story telling class 1/2

## Solution

Running the program normally, we see this:
```
$ ./vuln
Tell me a story and then I'll tell you one >> aaaaaaaaaaaaaaaaaaa
Here's a story - 
aaaaaaaaaaaaaaaaaaa
```

This challenge was tagged with "format_string", and this is a major suggestion on how we can go about exploiting this binary. 

A format string exploit refers to abusing the `scanf()` and `printf()` functions in C to leak information from the program. The source code has been given to us, so we can confirm this is correct.
```
void vuln(){
   char flag[BUFSIZE];
   char story[128];

   readflag(flag, FLAGSIZE);

   printf("Tell me a story and then I'll tell you one >> ");
   scanf("%127s", story);
   printf("Here's a story - \n");
   printf(story);
   printf("\n");
}
```

From the above code, the program receives our input with `scanf()`, but the lack of a format specifier with `printf()` makes this function vulnerable. Examples of format specifiers include `%s` or `%x`, and they're used to print a particular type of data (strings, integers, hexadecimal).
* For better security, `printf("%s", story)` should be used instead.

If we supply input as format specifiers, we should be able to leak information. The `%x` format specifier should be used because it reads data from the stack, and the `$` can be used to leak an address from a certain position. We have to play around with this to get it right. In Python, a for loop like this is handy for building the payload:
```
for i in range(36, 50):
    payload += b".%" + str(i).encode() + b"$x"
```

I found the flag starts at the 36th position. Run the exploit script (see below) to get this string:
`b'.6f636970.7b465443.6b34334c.5f676e31.67346c46.6666305f.3474535f.345f6b63.65353133.7d666631.fbad000a.e0ec2200.3e8.804c000\n'`

Swap the endianness (CyberChef works well.) to see the flag.

**Flag: picoCTF{L34k1ng_Fl4g_0ff_St4ck_4315e1ff}**
